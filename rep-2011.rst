REP: 2011
Title: Evolving Message Types, and Other ROS Interface Types, Over Time
Author: William Woodall <william@openrobotics.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 30-Nov-2021
Post-History:


Abstract
========

This REP proposes patterns and approaches for evolving message, service, and action ROS interface types over time.

The proposed patterns use the existing default serialization technology, i.e. CDR, in combination with new tooling.
However, technologies provided by different, perhaps future, serialization technologies can always be used in addition.

Specifically, this REP proposes that interpreting older versions of the message at runtime can be achieved by using its type information and then converting it to the current version of the message using user-defined transfer functions.
This approach is a good way to achieve backwards compatibility in messages over long periods of time and in a variety of scenarios, e.g. over the wire, converting bag files, or in specialized tools.

This approach does not rely on specific features of the serialization technology and instead relies on the ability to communicate the type information of the messages on the wire, beyond their name and version, and use that to dynamically interpret it at runtime.

This approach can be used in conjunction with serialization technology specific features like optional fields, inheritance, etc., but it works even with the simplest serialization technologies so long as we have the ability to introspect the messages at runtime without prior knowledge of the type information, which is a feature we also need for generic introspection tools.

Also covered in this REP are recommended changes to the middleware API in ROS 2, as well as additional infrastructure, to support dynamic interpretation of messages at runtime.
It is very similar to, though slightly narrower and more generic than, the DDS-XTypes specification, and an interface similar to DDS-XTypes will likely be adopted in the ROS 2 middleware API, without explicitly relying on it.

Alternatives are also discussed in more detail.

Motivation
==========

Evolving types over time is a necessary part of developing a new system using ROS 2 as well as a necessary part of evolving ROS 2 itself over time.
As needs change, types often need to change to accommodate new use cases by adding or removing fields, changing the type of fields, or splitting/combining messages across different topics.

To understand this need, it's useful to look at a few common scenarios, for example consider this message definition (using the "rosidl" ``.msg`` format for convenience, but it could just as easily be the OMG IDL ``.idl`` format or something else like protobuf):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature

There are many potential issues with this message type, but it isn't uncommon for messages like this to be created in the process of taking an idea from a prototype into a product, and for the sake of this example, let's say that after using this message for a while the developers wanted to change the temperature field's type from int64 to float64.
There are a few ways the developers could approach this, e.g. if the serialization technology allowed for optional fields, they may add a new optional field like this (pseudo code):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature
    optional float64 temperature_float

Updated code could use it like this:

.. code::

    void on_temperature(const Temperature & temp) {
      // ...
      double actual_temp = 0.0;
      if (temp.temperature_float_is_set()) {
        actual_temp = temp.temperature_float();
      } else {
        actual_temp = static_cast<double>(temp.temperature());
      }
    }

This is not uncommon to see in projects, and it has the advantage that old data, whether it is from a program running on an older machine or is from old recorded data, can be interpreted by newer code without additional machinery or features beyond the optional field type.
Older publishing code can also use the new definition without being updated to use the new ``temperature_float`` field, which is very forgiving for developers in a way, but likely wouldn't be good long term solution.

You can imagine other serialization features, like inheritance or type coercion, could be used to address this desired change, but in each case it relies on a feature of the serialization technology which may or may not be available in all middleware implementations for ROS 2.

Each of these approaches also requires a more sophisticated message API for the users than what is currently provided by ROS 2.
At the moment the user can access all fields of the message directly, i.e. "member based access" vs "method based access", and that would need to change in some way to use some of these features.

A different approach would be to simply update the type as follows:

.. code::

    # Temperature.msg
    uint64 timestamp
    float64 temperature

And also update any code publishing or subscribing to this type at the same time.
This is typically what happens right now in ROS 2, and also what happened historically in ROS 1.
This approach is simple and requires no additional serialization features, but obviously doesn't do anything on its own to help developers evolve their system while maintaining support for already deployed code and utilizing existing recorded data.

However, with additional tooling these cases can be handled without the code of the application knowing about.
Consider again the above example, but this time the update to the message was done without backwards compatibility in the message definition.
This means that publishing old recorded data, for example, will not work with new code that subscribes to the topic but expects the new version of the message.
For the purpose of this example, let's call the original message type ``Temperature`` and the one using ``float64`` we'll call ``Temperature'``.
So, if you have rosbag2 publishing ``Temperature`` messages and a program consuming ``Temperature'`` messages they will not communicate, unless you have an intermediate program doing the translation.

.. code::

    ┌─────────┐  publishes     ┌──────────────┐ publishes     ┌─────┐
    │ rosbag2 ├───────────────►│transfer func.├──────────────►│ App │
    └─────────┘  Temperature   └──────────────┘ Temperature'  └─────┘

The "transfer function" can be user-defined, or for simple changes (like changing the field type to a compatible type) it can be done automatically.
We already do something like this for the ROS 1 to ROS 2 bridge in order to handle changes between message types in ROS 1 and ROS 2, and something like this was also done for rosbags in ROS 1 with the "bag migration rules" feature.

Furthermore, the "transfer function" approach also allows for runtime transformation of messages that only change in field semantics (e.g., a change of ``float distance`` to mean centimeters instead of meters, but with no change in field name or type).
Although in those cases, users will likely have to define the transfer function themselves.

.. TODO:: cite the above

This approach requires a few features, like the ability to have a single application read old and new versions of a message at the same time, and it requires more infrastructure and tooling to make it work, but it has the advantage of keeping both the publishing and subscribing code simple, i.e agnostic to the fact that there are other versions of the message, and it keeps the message type from being cluttered with vestigial fields.

Either way, a problem can usually be solved by changing a message in some of, if not all, of the of the above mentioned ways, and is often influenced by what the underlying technology allows for or encourages.
ROS 2 has special considerations on this topic because it can support different serialization technologies, though CDR is the default and most common right now, and those technologies have different capabilities.
It is neither desirable to depend on features of a specific technology, therefore tying ROS 2 to a specific technology, nor is it desirable suggest patterns that rely on features that only some serialization technologies provide, again tying ROS 2 to some specific technologies through their features.

We will require some features from the middleware and serialization technology, however, to handle evolving interfaces, but we should try to choose approaches which give ROS 2 the broadest support across middleware implementations, ideally while not limiting users from using specific features of the underlying technology when that suites them.

With those examples and design constraints as motivation, this REP makes a proposal on how to handle evolving message types in the following Specification section, as well as a rationale in the Rationale section and a discussion of alternatives in the Alternatives section and its sub-sections.

Terminology
===========

TODO


Specification
=============

The proposal is to provide tooling to help users identify when messages have changed, help users configure their system to convert between versions of messages on the fly, and help users write the code needed to convert between types when the conversion is not trivial.

Conceptual Overview
-------------------

Users will be able to calculate the "type version hash" for an interface (e.g. a message, service, or action) using the ``ros2 interface hash <package_name> <interface_name>`` command.
Additionally, if a topic has two types being used on it with the same type name, but different type versions, a warning will be logged and the endpoints that do not match will not communicate.

.. TODO:: how does this interact with serialization features like optional fields and inheritance? Is there a way to override this behavior when the hashes don't match but communication will work due to optional fields or inheritance?

When a mismatch is detected, the user can use predefined, or user-defined, "transfer functions" to convert between versions of the type until it is in the type they wish to send or receive.
They can use a tool that will look at a catalogue of available transfer functions to find a single transfer function, or a set of transfer functions, to get from the current type version to the desired type version.
The tool will start with the current type version and see if it can be automatically converted to the desired type version, or if it is accepted as an input to any user-defined transfer functions or if it can be automatically converted into one of the input type versions for the transfer functions.
It will continue to do this until it reaches the desired type version or it fails to find a path from the current to the desired type version.

Once the set of necessary transfer functions has been identified, the ROS graph can be changed to have one side of the topic be remapped onto a new topic name which indicates it is of a different version that what is desired, and then the transfer function can be run as a component node which subscribes to one version of the message, performs the conversion using the chain of transfer functions, and then publishes the other version of the message.
Tools will assist the user in making these remappings and running the necessary component nodes with the appropriate configurations, either from their launch file or from the command line.

.. TODO:: discuss the implications for large messages and the possibility of having the transfer functions be colocated with either the publisher or subscription more directly than with component nodes and remapping.

Once the mismatched messages are flowing through the transfer functions, communication should be possible and neither the publishing side nor the subscribing side have any specific knowledge of the conversions taking place or that any conversions are necessary.

In order to support this vision, three missing features will need to be added into ROS 2: controlling matching based on the type version hash (interface type enforcement), communicating the interface type description between nodes (inter-process type description distribution), and (de)serializing messages and services given only a type description of the interface and a buffer of bytes (runtime type introspection).

Interface Type Enforcement
--------------------------

In order to detect type version mismatches and enforce them, a way to uniquely identify versions is required, and this proposal uses type version hashes.

Type Version Hash
~~~~~~~~~~~~~~~~~

The type version hashes are not sequential and do not imply any rank among versions of the type. That is, given two version hashes of a type, there is no way to tell which is "newer".

The type version hash can only be used to determine if type versions are equal and if there exists a chain of transfer functions that can convert between them.
Because of this, when a change to a type is made, it may or may not be necessary to write transfer functions in both directions depending on how the interface is used.

In order to calculate the type version hashes so that they are stable and are not sensitive to trivial changes like changes in the comments or whitespace in the IDL file, the IDL file given by the user, which may be a ``.msg`` file, ``.idl`` file, or something else, is parsed and stored into a data structure which excludes things like comments but includes things that impact compatibility on the wire.

The data structure includes:

- a list of field names and types, but not default values
- the serialization format
- the serialization format version
- an optional user-defined interface version, or 0 if not provided

The resulting data structure is hashed using a standard SHA-1 method, resulting in a standard 160-bit (20-byte) hash value which is also generally known as a "message digest".
This hash is combined with a "type version hash standard version", the first of which will be ``IDLHASH-1``, with an ``@`` symbol, resulting in a complete type version hash like ``IDLHASH-1@<160-bit SHA-1 of data structure>``.
This allows the tooling to know if a hash mismatch is due to a change in this standard (what is being hashed) or due to a difference in the interface types themselves.

The user-defined interface version makes it possible to change the version of a message that only changed in "field semantics" (i.e. without changing field names or types), and therefore makes it possible to write "transfer functions" to handle semantic-only conversions between versions.

.. TODO:: is the list of field names and types sufficient? how to capture things like .idl annotations, etc... I'm thinking of serialization format specific entries can be added to this data structure, but need to sketch it out a bit more

Enforcing Type Version
~~~~~~~~~~~~~~~~~~~~~~

The type version hash can be used as an additional constraint to determine if two endpoints (publishers and subscriptions) on a topic should communicate.

When creating a publisher or subscription, the caller normally provides: a topic name, QoS settings, and a topic type.
The topic type is represented as a string and is automatically deduced based on the type given to the create function, e.g. as a template parameter in C++ or the message type as an argument in Python.
For example, creating a publisher for ``std_msgs::msg::String`` in C++, may result in a topic type like ``std_msgs/msg/String``.
All of these items are used by the middleware to determine if two endpoints should communicate or not, and this REP proposes that the type version be added to this list of provided information.
Nothing needs to change from the user's perspective, as the type version can be extracted automatically based on the topic type given, either at the ``rcl`` layer or in the ``rmw`` implementation itself.
However, the type version would become something that the ``rmw`` implementation is provided and aware of in the course of creating a publisher or subscription, and therefore the job of using that information to enforce type compatibility would be left to the middleware, rather than implementing it as logic in ``rcl`` or other packages above the ``rmw`` API.

The method for implementing the detection and enforcement of type version mismatches is left up to the middleware, as some middlewares will have tools to make this efficient and others will implement something like what would be possible in the ``rcl`` and above layers.
By keeping this a detail of the ``rmw`` implementation, we allow the ``rmw`` implementations to make optimizations where they can.

Recommended Strategy for Enforcing that Type Versions Match
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the middleware has a feature to handle type compatibility already, as is the case with DDS-XTypes which is discussed later, then that can be used to enforce type safety, and then the type version hash can be used to warn the user when the communication may not happen due to a version mismatch, and also if can be put into recordings for future comparison.

However, if the middleware lacks this kind of feature, then the recommended strategy for accomplishing this in the ``rmw`` implementation is to simply concatenate the type name and the type version hash and then use that as the type name given to the underlying middleware.
This has the benefit of "just working" for most middlewares which at least match based on the name of the type, and it is simple, requiring no further custom hooks into the middleware's discovery or match making process.
However, the downside is that detecting the mismatch is more difficult and it also makes interoperating with ROS using the native middleware more difficult, as appending the version hash to the type name is just "one more thing" that you have to contend with when trying to connect non-ROS endpoints to a ROS graph.

.. TODO:: figure out if mismatched types produces a IncompatibleQoSOffered callback or not, then document the recommended way to detect type version mismatches, also look into ``DDS XTypes spec v1.3: 7.6.3.4.2: INCONSISTENT_TOPIC`` as a possible alternative

Notes for Implementing the Recommended Strategy with DDS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

Interactions with DDS-XTypes or Similar Implicit Middleware Features
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO


.. TODO:: move the draft section with details here after one of these options is selected: USER_DATA+ignore, USER_DATA+discovery "plugin", append type hash to type name in DDS, use type hash in DDS partition

Type Description Distribution
-----------------------------

For some use cases the type version hash is insufficient and instead the full type description is required.

One of those use cases, which is also described in this REP, is "runtime type introspection", which is the ability to introspect the contents of a message at runtime when the description for that message, or that version of that message, was unavailable at compile time.
In this use case the type description is used to interpret the serialized data dynamically.

Another use case, which is not covered in this REP, is using the type description in tooling to either display the type description to the user or to include it in recordings like rosbags.

In either case, where the type description comes from doesn't really matter, and so, for example, it could be looked up on the local filesystem or read from a rosbag file.
However, in practice, the correct type description may not be found locally, especially in cases where you have different versions of messages in the same system, either because it's on another computer or perhaps because it is from a different distribution of ROS or was built in a different workspace.

So, it is useful to have a mechanism to convey the type descriptions from the source of the data to other nodes, which we describe here as "type description distribution".
Furthermore, this feature should be agnostic to the underlying middleware and serialization library.

Sending the Type Description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. TODO:: should each publisher be contacted for each type/version pair or should we assume that the type/version pair guarantees a unique type description?

Type descriptions will be provided by a ROS Service (``~/_get_type_description``) on each node.
There will be a single ROS service per node, regardless of the number of publishers or subscriptions on that node.

.. TODO:: should this service be required/optional?

A service request to this ROS Service will comprise of the type name and the type version hash, which is distributed during discovery of endpoints and will be accessible through the ROS API.
The service server will respond with the type description and any necessary metadata needed to do runtime type introspection.
This service is not expected to be called frequently, and is likely to only occur when new topic or service endpoints are created, and even then, only if the endpoint type hashes do not match.

Type Description Contents and Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The response sent by the service server will contain a combination of the original ``idl`` or ``msg`` file's content, as well as any necessary information to serialize and deserialize the raw message buffers sent on the topic.
The response will contain a version of the description that contains comments from the original type description, as those might be relevant to interpreting the semantic meaning of the message fields.

Additionally, the response could include the serialization library used, its version, or any other helpful information from the original producer of the data.

All of this type description information will be sent as a ROS 2 service response, as the nodes in the previous section will be queried on the ROS layer.

.. TODO:: What happens if the message consumer doesn't have access to the serialization library stated in the meta-type?

The ROS 2 message that defines the type description must be able to describe any message type, including itself, and since it is describing the message format, it should work independently from any serialization technologies used.
This "meta-type description" message would then be used to communicate the structure of the type as part of the "get type description" service response.
The final form of these interfaces should be found in the reference implementation, but such a Service interface might look like this:

.. code::

    string type_name
    string version_hash
    ---
    bool successful  # True if the type description information is available and populated in the response
    string failure_reason  # Empty if 'successful' was true, otherwise contains details on why it failed

    string type_description_raw  # The idl or msg file, with comments and whitespace
    TypeDescription type_description  # The parsed type description which can be used programmatically

    string serialization_library
    string serialization_version
    # ... other useful meta data

Again, the final form of these interfaces should be referenced from the reference implementation, but the ``TypeDescription`` message type might look like this:

.. code::

    IndividualTypeDescription type_description
    IndividualTypeDescription[] referenced_type_descriptions

And the ``IndividualTypeDescription`` type:

.. code::

    string   type_name
    Field[]  fields

And the ``Field`` type:

.. code::

    NESTED_TYPE = 0
    FIELD_TYPE_INT = 1
    FIELD_TYPE_DOUBLE = 2
    # ... and so on

    uint8_t field_type
    string  field_name
    string  nested_type_name  # If applicable (when field_type is 0)

These naive examples of the interfaces just give an idea of the structure but perhaps do not yet consider some other complications like field annotations and more advanced IDL (generically all "interface description languages" not just the OMG-IDL that DDS uses) have.

Nested TypeDescription Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``TypeDescription`` message type shown above also supports the complete description of a type that contains other types (a nested type), up to an arbitrary level of nesting.
Consider the following example:

.. code::

  # A.msg
  B b
  C c

  # B.msg
  bool b_bool

  # C.msg
  D d

  # D.msg
  bool d_bool

The corresponding ``TypeDescription`` for ``A.msg`` will be as follows:

.. code::

  # A: TypeDescription
  type_description: A_IndividualTypeDescription
  referenced_type_descriptions: [B_IndividualTypeDescription,
                                 C_IndividualTypeDescription,
                                 D_IndividualTypeDescription]

With the referenced type descriptions accessible as ``IndividualTypeDescription`` types in the ``referenced_type_descriptions`` field of ``A`` (and also for `A`, its own ``type_description`` field.
In the case where a type description contains no referenced types (i.e., when it has no fields, or all of its fields are primitive types), the ``referenced_type_descriptions`` array will be empty.

.. code::

  # A: IndividualTypeDescription
  type_name: "A"
  fields: [A_b_Field, A_c_Field]

  # B: IndividualTypeDescription
  type_name: "B"
  fields: [B_b_bool_Field]

  # C: IndividualTypeDescription
  type_name: "C"
  fields: [C_d_Field]

  # D: IndividualTypeDescription
  type_name: "D"
  fields: [D_d_bool_Field]

With the corresponding ``Field`` fields:

.. code::

  # A_b_Field
  field_type: 0
  field_name: "b"
  nested_type_name: "B"

  # A_c_Field
  field_type: 0
  field_name: "c"
  nested_type_name: "C"

  # B_b_bool_Field
  field_type: 9         # Suppose 9 corresponds to a boolean field
  field_name: "b_bool"
  nested_type_name: ""  # Empty if primitive type

  # C_d_Field
  field_type: 0
  field_name: "d"
  nested_type_name: "D"

  # D_d_bool_Field
  field_type: 9
  field_name: "d"
  nested_type_name: ""

In order to handle the type of a nested type such as ``A``, the receiver can use the ``referenced_type_descriptions`` array as a lookup table keyed by the value of ``Field.nested_type_name`` or ``IndividualTypeDescription.type_name`` (which will be identical for a given type) to obtain the type information of a referenced type.
This type handling process can also support any recursive level of nesting (e.g. while handling A, C is encountered as a nested type, C can then be looked up using the top level ``referenced_type_descriptions`` array).

Additional Notes for TypeDescription Message Type
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Given that the type description message interface has to be generic enough to support anything described in the ROS interfaces, there will be a need to add or remove fields over time in the type description message itself.
This should be done in such a way that the fields are tick-tocked and deprecated properly, possibly by having explicitly named versions of this interface, e.g. ``TypeDescriptionV1`` and ``TypeDescriptionV2`` and so on.

Implementation in the `rcl` Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The implementation of the type description distribution feature will be made in the ``rcl`` layer as opposed to the ``rmw`` layer to take advantage of the abstraction away from the middleware and to allow for compatibility with the client libraries.

A hook will be added to ``rcl_node_init()`` to initialize the type description distribution service with the appropriate ``rcl_service_XXX()`` functions.
This hook should also keep a map of published and subscribed types which will be populated on each initialization of a publisher or subscription in the respective ``rcl_publisher_init()`` and ``rcl_subscription_init()`` function calls.
The passed ``rosidl_message_type_support_t`` in the init call can be introspected with getter functions to obtain the relevant information, alongside any new methods added to support type version hashing.


Runtime Type Introspection
--------------------------

Runtime type introspection allows access to the data in the fields of a serialized message buffer when given:

- the serialized message as a ``rmw_serialized_message_t``, a.k.a. a ``rcutils_uint8_array_t``
- the message's type description, e.g. received from the aforementioned type description distribution or from a bag file
- the serialization format, name and version, which was used to create the serialized message, e.g. ``XCDR2`` for ``Extended CDR encoding version 2``

From these inputs, we should be able to access the data as fields in the message buffer through some programmatic interface, including:

- a list of field names
- a list of field types
- access to the field by name or index

.. code::

            message_buffer ─┐   ┌────────────────────────────┐
                            │   │                            │
       message_description ─┼──►│ Runtime Type Introspection ├───► Introspection Interface
                            │   │                            │
      serialization_format ─┘   └────────────────────────────┘

Given that the scope of inputs and expected outputs is so limited, this feature should ideally be implemented as a separate package, e.g. ``rcl_serialization``, that can be called independently by any downstream packages that might need runtime type introspection, e.g. introspection tools, rosbag transport, etc.
This feature can then be combined with the ability to detect type mismatches and obtain type descriptions in the previous two sections to facilitate communication between nodes of otherwise incompatible types.

Additionally, it is important to note that this feature is distinguished from ROS 2's "dynamic" type support (``rosidl_typesupport_introspection_c``) in that "dynamic" type support generates type support code at compile time that then is not expected to change, whereas this feature aims to support any arbitrary message type descriptions at runtime.
Crucially, this means that a node will not need access to a message's type description at compile time in order to be able to support it, since it will be able to receive and utilize the type description with this feature, in contrast to "dynamic" type support, which would require it.

Requirements
^^^^^^^^^^^^

In order for runtime type introspection to work, message buffers still need to be able to be transmitted and received, as such, this feature is expected to work if and only if:

- the consumer of a message has access to a compatible version of the serialization library described in the message type description
- the serialization libraries expected to be used with this feature support at least sequential access to message buffer data members with a runtime programmatic interface
- in the case where messages are being sent over a middleware layer (e.g. one of the DDS implementations), the producers and consumers of the message are using compatible middleware implementations

Furthermore, this feature will be implemented as a C library to allow for maximum interoperability with the ROS client libraries (e.g. C++, Python, Rust, etc.)

Plugin Interface
^^^^^^^^^^^^^^^^

As runtime type introspection is expected to work across any serialization format, the runtime type introspection interface needs to be extensible so that the necessary serialization libraries can be loaded to process the serialized message.
Serialization format support in this case will be provided by writing plugins that wrap the serialization libraries that can then provide the runtime type introspection feature with the needed facilities.
Then, runtime type introspection will:

- enumerate the supported serialization library plugins on the machine
- match, if possible, the serialization format specified in the message type description to an appropriate plugin (throwing a warning otherwise)
- dynamically load the plugin

These serialization library plugins must wrap functionality to:

- determine suitability for use with a message's reported serialization version and type
- parse the ``.idl`` / ``.msg`` component of the message description into a serialization library usable form
- given that parsed description (which provides type reflection information about the message buffer), deserialize the message buffer using the serialization library

In particular, the step of parsing the ``.idl``  / ``.msg`` file is necessary because there might be serialization library or type support specific steps or considerations (e.g. field re-ordering, endianness) that would not be captured in the ``.idl`` / ``.msg`` file, because they would have been assumed to have been applied during type support.

Dealing with Multiple Applicable Plugins for A Serialization Format
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In the case where there exists multiple applicable plugins for a particular serialization format (e.g. when a user's machine has both RTI Connext's CDR library and FastCDR), the plugin matching should follow this priority order:

- user specified overrides passed to the matching function
- defaults defined in the plugin matching function, if applicable, otherwise
- the first suitable plugin in alphanumeric sorting order


Example Plugin Interface
^^^^^^^^^^^^^^^^^^^^^^^^

Plugin Matching and Loading
"""""""""""""""""""""""""""

The following is an example of how this plugin matching and loading interface could look like, defining new ``rcl`` interfaces; with a plugin wrapping FastCDR v1.0.24 for serialization of ``sensor_msgs/msg/LaserScan`` messages:

.. code::

    // Suppose LaserScanDescription reports that it uses FastCDR v1.0.24 for its serialization
    rcl_message_description_t LaserScanDescription = node->get_type_description("/scan");

    rcl_type_introspection_t * introspection_handle;
    introspection_handle->init();  // Locate local plugins here

    // Plugin name: "fastcdr_v1_0_24"
    const char * plugin_name = introspection_handle->match_plugin(LaserScanDescription->get_serialization_format());
    rcl_serialization_plugin_t * plugin = introspection_handle->load_plugin(plugin_name);

    // If we wanted to force the use of MicroCDR instead
    introspection_handle->match_plugin(LaserScanDescription->get_serialization_type(), "microcdr");

Then, the plugin should be able to use the description to deserialize the message buffer using the plugin:

.. code::

    rcl_deserialized_message_t * scan_msg;
    introspection_handle->deserialize(&plugin, message_buffer, &LaserScanDescription, scan_msg);

    // Where, internally...
    // rcl_type_introspection_t->(*deserialize)
    void deserialize(rcl_serialization_plugin_t *plugin,
                     void *buffer,
                     rcl_message_description_t *description,
                     rcl_deserialized_message_t *msg)
    {
      ...

      // Do something serialization specific
      plugin_internal_description_t parsed_description = plugin->impl->parse_description(description);
      plugin->impl->deserialize(buffer, parsed_description, msg);

      ...
    }

Similar interfaces could be created to allow access a message's fields by name or index without deserializing the whole message.

Example Introspection API
^^^^^^^^^^^^^^^^^^^^^^^^^

Once the serialization library plugins are able to deserialize the raw message buffer, downstream programs can then introspect the constructed deserialized message object, which should be laid out as such:

.. code::

    struct rcl_deserialized_field_t {
        void * value;
        char * type;
    }

    struct rcl_deserialized_message_t {
        int message_field_count;
        const char** message_field_names;
        const char** message_types;

        // Some dynamically allocated key->value associative map type storing void * field values
        rcl_associative_array message_fields;

        // Function pointers
        rcl_deserialized_field_t * (*get_field_by_index)(int index);
    };

Now, for a given message description `Foo.msg`:

.. code::

    // Foo.msg
    bool bool_field
    char char_field
    float32 float_field

The corresponding `rcl_deserialized_message_t` can be queried accordingly:

.. code::

    rcl_deserialized_message_t * foo_msg;
    foo_msg->message_field_names[0];  // "bool_field"
    foo_msg->message_types[0];  // "bool"

    // Get the field
    if (strcmp("bool", foo_msg->get_field_by_index(0)->type) == 0)
    {
        *((bool*)foo_msg->get_field_by_index(0)->value);
    }

.. TODO:: Create pseudocode/definitions for sequences and arbitrarily nested message descriptions.

Rationale
=========

TODO

Type Description Distribution
-----------------------------

Using a Single ROS Service per Node
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The node that is publishing the data must already have access to the correct type description, at the correct version, in order to publish it, and therefore it is natural to get the data from that node.
Similarly, a subscribing node also knows what type they are wanting to receive, both in name and version, and therefore it is again natural to get that information from the subscribing node.
The type description for a given type, at a given version, could have been retrieved from other places, e.g. a centralized database, but the other alternatives considered would have had to take care to ensure that it had the right version of the message, which is not the case for the node publishing the data.

Because the interface for getting a type description is generic, it is not necessary to have this interface on a per entity, i.e. publisher, subscription, etc, basis, but instead to offer the ROS Service on a per node basis to reduce the number of ROS Services.
Therefore, the specification dictates that the type description is distributed by single ROS Service for each individual node.

There were also multiple alternatives for how to get this information from each node, but the use of a single ROS Service was selected because the task of requesting the type description from a node is well suited to a request-response style ROS Service.
Some of the alternatives offered other benefits, but using a ROS Service introduced the fewest dependencies, feature-wise, while accomplishing the task.

.. TODO:: cite the above, https://en.wikipedia.org/wiki/Request%E2%80%93response

Combining the Raw and Parsed Type Description in the Service Response
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The contents of the "get type description" service response should include information that supports both aforementioned use cases (i.e. tools and runtime type introspection).
These use cases have orthogonal interests, with the former requiring human-readable descriptions, and the latter preferring machine-readable descriptions.

Furthermore, the type description should be useful even across middlewares and serialization libraries and that makes it especially important to send at least the original inputs to the "type support pipeline" (i.e. the process of taking user-defined types and generating all supporting code).
In this case, because the "type support pipeline" is a lossy process, there is a need to ensure that enough information is sent to completely reproduce the original definition of the type, and therefore it makes sense to just send the original ``idl`` or ``msg`` file.

At the same time, it is useful to send information with the original description that makes it easier to process data at the receiving end, as it is often not trivial to get to the "parsed" version of the type description from the original text description.

Finally, while there could be an argument for sending a losslessly compressed version of the message file, the expected low frequency of queries to the type description service incurs a negligible overhead that heavily reduces the benefit.

Implementing in ``rcl`` versus ``rmw``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While it is true that implementing the type description distribution on the ``rmw`` layer would allow for much lower level optimization, removing the layer of abstraction avoids having to implement this feature in each rmw implementation.

Given that the potential gains from optimization will be small due to how infrequently the service is expected to be called, this added development overhead was determined to not be worth it.
Instead the design prefers to have a unified implementation of this feature in ``rcl`` so it is agnostic to any middleware implementations and client libraries.

Alternatives
------------

TODO

Use Type Hash from Middleware, e.g. from DDS-XTypes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Handle Detection of Version Mismatch "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Prevent Communication of Mismatched Versions "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TODO

Type Description Distribution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Other Providers of Type Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Several other candidate strategies for distributing the type descriptions were considered but ultimately discarded for one or more reasons like: causing a strong dependency on a particular middleware or a third-party technology, difficulties with resolving the message type description locally, difficulties with finding the correct entity to query, or causing network throughput issues.

These are some of the candidates that were considered, and the reasons for their rejection:

- Store the type description as a ROS parameter
   * Causes a mass of parameter event messages being sent at once on init, worsening the network initialization problem
- Store the type description on a centralized node per machine
   * Helps reduce network bandwidth, but makes it non-trivial to find the correct centralized node to query, and introduces issues of resolving the local message package, such as when nodes are started from different sourced workspaces.
- Send type description alongside discovery with middlewares
   * Works very well if supported, but is only supported by some DDS implementations (which support XTypes or some other way to attach discovery metadata), but causes a strong dependency on DDS.
- Send type description using a different network protocol
   * Introduces additional third-party dependencies separate from ROS and the middleware.

Alternative Type Description Contents and Format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A combination of the original ``idl`` / ``msg`` file and any other information needed for serialization and deserialization being sent allows for one to cover the weaknesses of the other.
Specifically, given that certain use-cases (e.g., ``rosbag``) might encounter situations where consumers of a message are using a different middleware or serialization scheme the message was serialized with, it becomes extremely important to send enough information to both reconstruct the type support, and also allow the message fields to be accessed in a human readable fashion to aid in the writing of transfer functions.
As such, it is not a viable option to only send one or the other.

Additionally, the option to add a configuration option to choose what contents to receive from the service server was disregarded due to how infrequently the type description query is expected to be called.

As for the format of the type description, using the ROS interfaces to describe the type, as opposed to an alternative format like XML, JSON, or something like the TypeObject defined by DDS-XTypes, makes it easier to embed in the ROS Service response.
It also prevents unnecessary coupling with third-party specifications that could be subject to change and reduces the formats that need to be considered on the receiving end of the ROS Service call.

TypeDescription Structure
~~~~~~~~~~~~~~~~~~~~~~~~~

Representing Fields as An Array of Field Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The use of an array of ``Field`` messages was balanced against using two arrays in the ``IndividualTypeDescription`` type to describe the field types and field names instead, e.g.:

.. code::

  # Rejected IndividualTypeDescription Variants

  # String variant
  string type_name
  string field_types[]
  string field_names[]

  # uint8_t Variant
  string type_name
  uint8_t field_types[]
  string field_names[]

The string variant was rejected because using strings to represent primitive types wastes space, and will lead to increased bandwidth usage during the discovery and type distribution process.
The uint8_t variant was rejected because uint8_t enums are insufficiently expressive to support nested message types.

The use of the ``Field`` type, with a ``nested_type_name`` field that defaults to an empty string mitigates the space issue while allowing for support of nested message types.
Furthermore, it allows the fields to be described in a single array, which is easier to iterate through and also reduces the chances of any errors from mismatching the array lengths.

Using an Array to Store Referenced Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some alternatives to using an array of type descriptions to store referenced types in a nested type were considered, including:

- Storing the referenced types inside the individual type descriptions and accessing them by traversing the type description tree recursively instead of using a lookup table.

  - Rejected because the IDL spec does not allow for a type description to store itself, and also because it could possibly introduce duplicate, redundant type descriptions in the tree, using up unnecessary space.

- Sending referenced types in a separate service call or message.

  - Rejected because needing to collate all of the referenced types on the receiver end introduces additional implementation complexity, and also increases network bandwidth with all the separate calls that must be made.


Backwards Compatibility
=======================

TODO

Feature Progress
================

TODO


References
==========

.. [1] DDS-XTYPES 1.3
   (https://www.omg.org/spec/DDS-XTypes/1.3/About-DDS-XTypes/)


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
