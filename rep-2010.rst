REP: 2010
Title: Evolving Message Types, and Other ROS Interface Types, Over Time
Author: William Woodall <william@openrobotics.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 30-Nov-2021
Post-History:


Abstract
========

This REP proposes patterns and approaches for evolving message, service, and action ROS interface types over time.

The proposed patterns use the existing default serialization technology, i.e. CDR, in combination with new tooling.
However, technologies provided by different, perhaps future, serialization technologies can always be used in addition.

Specifically, this REP proposes that interpreting older versions of the message at runtime can be achieved by using its type information and then converting it to the current version of the message using user-defined transfer functions.
This approach is a good way to achieve backwards compatibility in messages over long periods of time and in a variety of scenarios, e.g. over the wire, converting bag files, or in specialized tools.

This approach does not rely on specific features of the serialization technology and instead relies on the ability to communicate the type information of the messages on the wire, beyond their name and version, and use that to dynamically interpret it at runtime.

This approach can be used in conjunction with serialization technology specific features like optional fields, inheritance, etc., but it works even with the simplest serialization technologies so long as we have the ability to introspect the messages at runtime without prior knowledge of the type information, which is a feature we also need for generic introspection tools.

Also covered in this REP are recommended changes to the middleware API in ROS 2, as well as additional infrastructure, to support dynamic interpretation of messages at runtime.
It is very similar to, though slightly narrower and more generic than, the DDS-XTypes specification, and an interface similar to DDS-XTypes will likely be adopted in the ROS 2 middleware API, without explicitly relying on it.

Alternatives are also discussed in more detail.

Motivation
==========

Evolving types over time is a necessary part of developing a new system using ROS 2 as well as a necessary part of evolving ROS 2 itself over time.
As needs change, types often need to change to accommodate new use cases by adding or removing fields, changing the type of fields, or splitting/combining messages across different topics.

To understand this need, it's useful to look at a few common scenarios, for example consider this message definition (using the "rosidl" ``.msg`` format for convenience, but it could just as easily be the OMG IDL ``.idl`` format or something else like protobuf):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature

There are many potential issues with this message type, but it isn't uncommon for messages like this to be created in the process of taking an idea from a prototype into a product, and for the sake of this example, let's say that after using this message for a while the developers wanted to change the temperature field's type from int64 to float64.
There are a few ways the developers could approach this, e.g. if the serialization technology allowed for optional fields, they may add a new optional field like this (pseudo code):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature
    optional float64 temperature_float

Updated code could use it like this:

.. code::

    void on_temperature(const Temperature & temp) {
      // ...
      double actual_temp = 0.0;
      if (temp.temperature_float_is_set()) {
        actual_temp = temp.temperature_float();
      } else {
        actual_temp = static_cast<double>(temp.temperature());
      }
    }

This is not uncommon to see in projects, and it has the advantage that old data, whether it is from a program running on an older machine or is from old recorded data, can be interpreted by newer code without additional machinery or features beyond the optional field type.
Older publishing code can also use the new definition without being updated to use the new ``temperature_float`` field, which is very forgiving for developers in a way, but likely wouldn't be good long term solution.

You can imagine other serialization features, like inheritance or type coercion, could be used to address this desired change, but in each case it relies on a feature of the serialization technology which may or may not be available in all middleware implementations for ROS 2.

Each of these approaches also requires a more sophisticated message API for the users than what is currently provided by ROS 2.
At the moment the user can access all fields of the message directly, i.e. "member based access" vs "method based access", and that would need to change in some way to use some of these features.

A different approach would be to simply update the type as follows:

.. code::

    # Temperature.msg
    uint64 timestamp
    float64 temperature

And also update any code publishing or subscribing to this type at the same time.
This is typically what happens right now in ROS 2, and also what happened historically in ROS 1.
This approach is simple and requires no additional serialization features, but obviously doesn't do anything on its own to help developers evolve their system while maintaining support for already deployed code and utilizing existing recorded data.

However, with additional tooling these cases can be handled without the code of the application knowing about.
Consider again the above example, but this time the update to the message was done without backwards compatibility in the message definition.
This means that publishing old recorded data, for example, will not work with new code that subscribes to the topic but expects the new version of the message.
For the purpose of this example, let's call the original message type ``Temperature`` and the one using ``float64`` we'll call ``Temperature'``.
So, if you have rosbag2 publishing ``Temperature`` messages and a program consuming ``Temperature'`` messages they will not communicate, unless you have an intermediate program doing the translation.

.. code::

    ┌─────────┐  publishes     ┌──────────────┐ publishes     ┌─────┐
    │ rosbag2 ├───────────────►│transfer func.├──────────────►│ App │
    └─────────┘  Temperature   └──────────────┘ Temperature'  └─────┘

The "transfer function" can be user-defined, or for simple changes (like changing the field type to a compatible type) it can be done automatically.
We already do something like this for the ROS 1 to ROS 2 bridge in order to handle changes between message types in ROS 1 and ROS 2, and something like this was also done for rosbags in ROS 1 with the "bag migration rules" feature.

Furthermore, the "transfer function" approach also allows for runtime transformation of messages that only change in field semantics (e.g., a change of ``float distance`` to mean centimeters instead of meters, but with no change in field name or type.) Although in those cases, users will likely have to define the transfer function themselves.

.. TODO:: cite the above

This approach requires a few features, like the ability to have a single application read old and new versions of a message at the same time, and it requires more infrastructure and tooling to make it work, but it has the advantage of keeping both the publishing and subscribing code simple, i.e agnostic to the fact that there are other versions of the message, and it keeps the message type from being cluttered with vestigial fields.

Either way, a problem can usually be solved by changing a message in some of, if not all, of the of the above mentioned ways, and is often influenced by what the underlying technology allows for or encourages.
ROS 2 has special considerations on this topic because it can support different serialization technologies, though CDR is the default and most common right now, and those technologies have different capabilities.

It is neither desirable to depend on features of a specific technology, therefore tying ROS 2 to a specific technology, nor is it desirable suggest patterns that rely on features that only some serialization technologies provide, again tying ROS 2 to some specific technologies through their features.

We will require some features from the middleware and serialization technology, however, to handle evolving interfaces, but we should try to choose approaches which give ROS 2 the broadest support across middleware implementations, ideally while not limiting users from using specific features of the underlying technology when that suites them.

With those examples and design constraints as motivation, this REP makes a proposal on how to handle evolving message types in the following Specification section, as well as a rationale in the Rationale section and a discussion of alternatives in the Alternatives section and its sub-sections.

Terminology
===========

TODO


Specification
=============

The proposal is to provide tooling to help users identify when messages have changed, help users configure their system to convert between versions of messages on the fly, and help users write the code needed to convert between types when the conversion is not trivial.

Conceptual Overview
-------------------

Users will be able to calculate the "type version hash" for an interface (e.g. a message, service, or action) using the ``ros2 interface hash <package_name> <interface_name>`` command.
Additionally, if a topic has two types being used on it with the same type name, but different type versions, a warning will be logged and the endpoints that do not match will not communicate.

.. TODO:: how does this interact with serialization features like optional fields and inheritance? Is there a way to override this behavior when the hashes don't match but communication will work due to optional fields or inheritance?

When a mismatch is detected, the user can use predefined, or user-defined, "transfer functions" to convert between versions of the type until it is in the type they wish to send or receive.
They can use a tool that will look at a catalogue of available transfer functions to find a single transfer function, or a set of transfer functions, to get from the current type version to the desired type version.
The tool will start with the current type version and see if it can be automatically converted to the desired type version, or if it is accepted as an input to any user-defined transfer functions or if it can be automatically converted into one of the input type versions for the transfer functions.
It will continue to do this until it reaches the desired type version or it fails to find a path from the current to the desired type version.

Once the set of necessary transfer functions has been identified, the ROS graph can be changed to have one side of the topic be remapped onto a new topic name which indicates it is of a different version that what is desired, and then the transfer function can be run as a component node which subscribes to one version of the message, performs the conversion using the chain of transfer functions, and then publishes the other version of the message.
Tools will assist the user in making these remappings and running the necessary component nodes with the appropriate configurations, either from their launch file or from the command line.

.. TODO:: discuss the implications for large messages and the possibility of having the transfer functions be colocated with either the publisher or subscription more directly than with component nodes and remapping.

Once the mismatched messages are flowing through the transfer functions, communication should be possible and neither the publishing side nor the subscribing side have any specific knowledge of the conversions taking place or that any conversions are necessary.

In order to support this vision, three missing features will need to be added into ROS 2: controlling matching based on the type version hash (interface type enforcement), communicating the interface type description between nodes (inter-process type description distribution), and (de)serializing messages and services given only a type description of the interface and a buffer of bytes (runtime type introspection).

Interface Type Enforcement
--------------------------

In order to detect type version mismatches and enforce them, a way to uniquely identify versions is required, and this proposal uses type version hashes.

Type Version Hash
~~~~~~~~~~~~~~~~~

The type version hashes are not sequential and do not imply any rank among versions of the type. That is, given two version hashes of a type, there is no way to tell which is "newer".

The type version hash can only be used to determine if type versions are equal and if there exists a chain of transfer functions that can convert between them.
Because of this, when a change to a type is made, it may or may not be necessary to write transfer functions in both directions depending on how the interface is used.

In order to calculate the type version hashes so that they are stable and are not sensitive to trivial changes like changes in the comments or whitespace in the IDL file, the IDL file given by the user, which may be a ``.msg`` file, ``.idl`` file, or something else, is parsed and stored into a data structure which excludes things like comments but includes things that impact compatibility on the wire.

The data structure includes:

- A list of field names and types, but not default values
- The serialization format
- The serialization format version
- An optional user-defined interface version, or 0 if not provided

The resulting data structure is hashed using a standard SHA-1 method, resulting in a standard 160-bit (20-byte) hash value which is also generally known as a "message digest".
This hash is combined with a "type version hash standard version", the first of which will be ``IDLHASH-1``, with an ``@`` symbol, resulting in a complete type version hash like ``IDLHASH-1@<160-bit SHA-1 of data structure>``.
This allows the tooling to know if a hash mismatch is due to a change in this standard (what is being hashed) or due to a difference in the interface types themselves.

Notably, the user-defined interface version being included in the hash allows for messages that only change in field semantics (i.e., without changing field names or types) to be picked up as discrepancies when they would not before, allowing users to be prompted to write "transfer functions" to resolve them.

.. TODO:: is the list of field names and types sufficient? how to capture things like .idl annotations, etc... I'm thinking of serialization format specific entries can be added to this data structure, but need to sketch it out a bit more

Enforcing Type Version
~~~~~~~~~~~~~~~~~~~~~~

If the type version hash is available, it can be used as an additional constraint to determine if two endpoints (publishers and subscriptions) on a topic should communicate.

When creating a publisher or subscription, the caller normally provides: a topic name, QoS settings, and a topic type.
The topic type is represented as a string and is automatically deduced based on the type given to the create function, e.g. as a template parameter in C++ or the message type as an argument in Python.
For example, creating a publisher for ``std_msgs::msg::String`` in C++, may result in a topic type like ``std_msgs/msg/String``.
All of these items are used by the middleware to determine if two endpoints should communicate or not, and this REP proposes that the type version be added to this list of provided information.
From the user's perspective, nothing needs to change, as the type version can be extracted based on the topic type given either at the ``rcl`` layer or in the ``rmw`` implementation itself.
However, the type version would become something that the ``rmw`` implementation is provided and aware of in the course of creating a publisher or subscription, and therefore the job of using that information to enforce type compatibility would be left to the middleware, rather than implementing it as logic in ``rcl`` or other packages above the ``rmw`` API.

The method for implementing the detection and enforcement of type version mismatches is left up to the middleware, as some middlewares will have tools to make this efficient and others will implement something like what would be possible in the ``rcl`` and above layers.
By keeping this a detail of the ``rmw`` implementation, we allow the ``rmw`` implementations to make optimizations where they can.

Recommended Strategy for Enforcing that Type Versions Match
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the middleware has a feature to handle type compatibility already, as is the case with DDS-XTypes which is discussed later, then that can be used to enforce type safety, and then the type version hash can be used to warn the user when the communication may not happen due to a version mismatch, and also if can be put into recordings for future comparison.

However, if the middleware lacks this kind of feature, then the recommended strategy for accomplishing this in the ``rmw`` implementation is to simply concatenate the type name and the type version hash and then use that as the type name given to the underlying middleware.
This has the benefit of "just working" for most middlewares which at least match based on the name of the type, and it is simple, requiring no further custom hooks into the middleware's discovery or match making process.
However, the downside is that detecting the mismatch is more difficult and it also makes interoperating with ROS using the native middleware more difficult, as appending the version hash to the type name is just "one more thing" that you have to contend with when trying to connect non-ROS endpoints to a ROS graph.

.. TODO:: figure out if mismatched types produces a IncompatibleQoSOffered callback or not, then document the recommended way to detect type version mismatches, also look into ``DDS XTypes spec v1.3: 7.6.3.4.2: INCONSISTENT_TOPIC`` as a possible alternative

Notes for Implementing the Recommended Strategy with DDS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

Interactions with DDS-XTypes or Similar Implicit Middleware Features
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO


.. TODO:: move the draft section with details here after one of these options is selected: USER_DATA+ignore, USER_DATA+discovery "plugin", append type hash to type name in DDS, use type hash in DDS partition

Inter-process Type Description Distribution
-------------------------------------------

If a mismatch in type hashes is found, the types might still be compatible.
In these cases, the full type description will have to be obtained in order to:

- Confirm type *compatibility* (e.g., the fields are the same, but the version number is different, or fields are implicitly castable)
- Support runtime type *introspection* (even without access to the message package)
- Support runtime type *transformation* (e.g., splitting, merging, casting, narrowing, renaming, arithmetic ops, etc.)

All of these features rely on there being some mechanism to communicate the type description across nodes on the network which might be located on different processes and different machines.
Furthermore, this feature should be agnostic to the underlying middleware and serialization library.

Sending the Type Description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. TODO:: we should probably decide what the name of that service is somewhere down the line

Type descriptions will be sent as a response to any query of a dedicated ROS service server (``/_query_type_description``) that will be started on initialization of each node on either end of a connection (e.g. publishers and/or subscriptions.)
There will only be one service started per node, independent of the number of publishers or subscriptions on that node.

A service request to this type description service will comprise of the type name and the version hash, which should be obtainable from the endpoint as specified in the previous section.
Upon receipt of the request, the service server will then construct a response by matching the request against its local list of available types and type hashes, populating the response with the type description and any necessary metadata, and send it. This service calling process is not expected to happen frequently per node, and is likely to only occur per registration of a new publisher or subscription connection, and even then, only if the endpoint type hashes do not match.

Type Description Contents and Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The type description response sent by the server will contain a combination of the original ``idl`` or ``msg`` file, and also any necessary information to serialize and deserialize the raw message buffers sent on the topic.
It should be noted that the section of the response that represents the ``idl`` or ``msg`` file will contain whitespace and comments, as those might be relevant to interpreting the semantic meaning of the message fields.

This information could include the serialization library used, its version, and the associated buffer offsets.
Or it could even include a shared object that can be dynamically loaded and called against to do the serialization or deserialization, and the name of the symbol to use.

All of this type description information will be sent as a ROS 2 service response, as the nodes in the previous section will be queried on the ROS layer.

.. TODO: What happens if the message consumer doesn't have access to the serialization library stated in the meta-type?

The ROS 2 service type that is meant to define the type description data is intended to be a meta-type description that is able to be used across any potential message types, for any potential serialization schemes used with ROS.
As such, it has to be general enough to account for this.
Such the meta-type description service type would look like:

.. TODO: We need to confirm this. This is probably very likely to change (e.g. splitting version into 3 numbers for MAJOR, MINOR, PATCH.)

.. code::

    string type_name 
    string version_hash
    ---
    bool available                 # True if the type description information is available and populated in the response 
    string metatype_version        # The version of this metatype descriptor

    string type_description_raw    # The idl or msg file, with comments and whitespace
    string type_description_parsed # The idl or msg file, in a cleaned form that can be fed into type support

    string serialization_library
    string serialization_version

    string type_support_meta       # Human readable metadata for the type support bytestring
    byte[] type_support            # Implementation specific serialization and deserialization support

Additional Notes for Type Description Meta-Type
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Given that the meta-type description has to be generic enough to support any combination of serialization libraries and formats, there is a high chance that it might need to be changed.
In these cases, there might be a need to add or remove fields on the meta-type description.
This should be done in such a way that the fields are tick-tocked and deprecated properly.

Implementation on the `rcl` Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The implementation of the type description distribution feature will be made on the ``rcl`` layer as opposed to the ``rmw`` layer to take advantage of the abstraction away from the middleware and to allow for compatibility with the client libraries.

.. TODO: Confirm the approach.

A hook will be added to ``rcl_node_init()`` to initialize the type description distribution service with the appropriate ``rcl_service_XXX()`` functions.
This hook should also initialize an ``std::unordered_map`` of published and subscribed types which will be populated on each initialization of a publisher or subscription in the respective ``rcl_publisher_init()`` and ``rcl_subscription_init()`` function calls.
The passed ``rosidl_message_type_support_t`` in the init call can be introspected with getter functions to obtain the relevant information, alongside any new methods added to support type version hashing.

.. TODO: (CH3) The ``rosidl_message_type_support_t`` contains ``void *`` pointers to the type support library. But I don't think it'll be able to get called if the blob is somehow sent over the air because the object wouldn't be available to call against, I think? Likewise with the function, the symbol name would be available, but a process which doesn't have the type support package won't be able to link against it or call it? I'm a little rusty with the type support pipeline.

Runtime Type Introspection
--------------------------

.. TODO:: terminology could be better? nothing off the top of my head, just deserves more bike-shedding.



Rationale
=========

TODO

Distributing Type Description via Services, as ``msg`` / ``idl``, on ``rcl``
----------------------------------------------------------------------------

Sending from Node
~~~~~~~~~~~~~~~~~

The resolution of the ROS graph and subscriptions afford information about what nodes are publishing or subscribing to any message topic.
Furthermore, in order for the nodes to register their publisher or subscription in the first place, they must have access to some version of the corresponding message type locally, even if they might have differing versions of the message type.
Notably, this guarantees that the node itself will have access to the type description, which removes any need to search for the correct service server when querying for type descriptions—a querying node may simply query the node that is advertising the topic.

Type Description as Combination Service Response
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The contents of the type description response sent by the service server should include information that supports most of the major use cases of this feature (namely, tools and type transformation to allow incompatible nodes to communicate.)
These use cases have orthogonal interests, with the former requiring human-readable descriptions, and the latter preferring machine-usable descriptions.

Furthermore, the constraint to have the type description be usable across middlewares and serialization libraries makes it especially important to send at least whatever information is necessary to regenerate the type support for any middleware or serialization library that is used on the receiving end.
In this case, because the type support pipeline is a lossy process, and there is a need to ensure that enough information is sent to completely reproduce the original msg file from the msg, losslessly, it makes sense to just send the original ``idl`` or ``msg`` file.
This also makes it important to send sufficient metadata about the serialization library and version used, since the type support pipeline for the serialized message might have changed, and that support information will be useful to resolve the changes.

Finally, while there could be an argument for sending a losslessly compressed version of the message file, the expected low frequency of queries to the type description service incurs a negligible overhead that heavily reduces the benefit.

Using ``rcl`` over ``rmw``
~~~~~~~~~~~~~~~~~~~~~~~~~~

While it is true that implementing the type description distribution on the ``rmw`` layer would allow for much lower level optimization (especially on the networking and middleware layers), removing the layer of abstraction means that any potential users of the feature will be required to look into the ``rmw`` layer, and middleware implementations will also need to be aware of this feature.

Given that the potential gains from optimization will be small due to how infrequently the service is expected to be called, this added development overhead is not a good trade-off.
It seems much better to have a unified implementation of this feature on ``rcl`` so it is agnostic to any middleware implementations and client libraries, and especially because services are a ROS construct.
However, the network performance will need to be monitored as this feature is being developed to see if all the extra services (even if they are hidden to the user) will necessitate using ``rmw`` instead of ``rcl``.

Alternatives
------------

TODO

Use Type Hash from Middleware, e.g. from DDS-XTypes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Handle Detection of Version Mismatch "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Prevent Communication of Mismatched Versions "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TODO

Inter-process Type Description Distribution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Other Providers of Type Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Several other candidate entities for provisioning the type description were considered but ultimately disregarded for reasons relating to either causing strong dependency on a middleware or a third-party technology, difficulties with resolving the message type description locally, difficulties with finding the correct entity to query, or causing network throughput issues.

These are some of the candidates that were considered, and the reasons for rejection:

- Store the type description as a ROS parameter
   * Causes a mass of parameter event messages being sent at once on init, worsening the network initialization problem
- Store the type description on a centralized node per machine
   * Helps reduce network bandwidth, but makes it non-trivial to find the correct centralized node to query, and introduces issues of resolving the local message package, such as when nodes are started from different sourced workspaces.
- Send type description alongside discovery with middlewares
   * Works very well if supported, but is only supported by some DDS implementations (which support XTypes or some other way to attach discovery metadata), but causes a strong dependency on DDS.
- Send type description using a different network protocol
   * Introduces additional third-party dependencies separate from ROS and the middleware.

Alternative Type Description Contents and Format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A combination of the original ``idl`` / ``msg`` file and serialization/deserialization specific objects being sent allows for one to cover the weaknesses of the other.
Specifically, given that certain use-cases (e.g., ``rosbag``) might encounter situations where consumers of a message are using a different middleware or serialization scheme the message was serialized with, it becomes extremely important to send enough information to both reconstruct the type support, and also allow the message fields to be accessed in a human readable fashion to aid in the writing of transfer functions.
As such, it is not a viable option to only send one or the other.

Additionally, the option to add a configuration option to choose what contents to receive from the service server was disregarded due to how infrequently the type description query is expected to be called.

As for message format, using the ROS service type as opposed to an alternative format like XML, JSON, or something DDS specific like XTypes, allows for greater support with the messaging scheme (ROS services) chosen, and also prevents unnecessary coupling with third-party specifications that could be subject to change.


Backwards Compatibility
=======================

TODO

Feature Progress
================

TODO


References
==========

.. [1] DDS-XTYPES 1.3
   (https://www.omg.org/spec/DDS-XTypes/1.3/About-DDS-XTypes/)


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
