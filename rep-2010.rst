REP: 2010
Title: Evolving Message Types, and Other ROS Interface Types, Over Time
Author: William Woodall <william@openrobotics.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 30-Nov-2021
Post-History:


Abstract
========

This REP proposes patterns and approaches for evolving message, service, and action ROS interface types over time.

The proposed patterns use the existing default serialization technology, i.e. CDR, in combination with new tooling.
However, technologies provided by different, perhaps future, serialization technologies can always be used in addition.

Specifically, this REP proposes that the following is a good way to achieve backwards compatibility in messages over long periods of time and in a variety of scenarios, e.g. over the wire, converting bag files, or in specialized tools:

- Interpreting older versions of the message at runtime;
- Using its type information;
- And converting it to the current version of the message using user defined transfer functions

This approach does not rely on specific features of the serialization technology and instead relies on the ability to communicate the type information of the messages on the wire, beyond their name and version, and use that to dynamically interpret it at runtime.

This approach can be used in conjunction with serialization technology specific features like optional fields, inheritance, etc., but it works even with the simplest serialization technologies so long as we have the ability to introspect the messages at runtime without prior knowledge of the type information, which is a feature we also need for generic introspection tools.

Also covered in this REP are recommended changes to the middleware API in ROS 2, as well as additional infrastructure, to support dynamic interpretation of messages at runtime.
It is very similar to, though slightly narrower and more generic than, the DDS-XTypes specification, and an interface similar to DDS-XTypes will likely be adopted in the ROS 2 middleware API, without explicitly relying on it.

Alternatives are also discussed in more detail.

Motivation
==========

Evolving types over time is a necessary part of developing a new system using ROS 2 as well as a necessary part of evolving ROS 2 itself over time.
As needs change, types often need to change to accommodate new use cases by adding or removing fields, changing the type of fields, or splitting/combining messages across different topics.

To understand this need, it's useful to look at a few common scenarios, for example consider this message definition (using the "rosidl" ``.msg`` format for convenience, but it could just as easily be the OMG IDL ``.idl`` format or something else like protobuf):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature

There are many potential issues with this message type, but it isn't uncommon for messages like this to be created in the process of taking an idea from a prototype into a product, and for the sake of this example, let's say that after using this message for a while the developers wanted to change the temperature field's type from int64 to float64.
There are a few ways the developers could approach this, e.g. if the serialization technology allowed for optional fields, they may add a new optional field like this (pseudo code):

.. code::

    # Temperature.msg
    uint64 timestamp
    int64 temperature
    optional float64 temperature_float

Updated code could use it like this:

.. code::

    void on_temperature(const Temperature & temp) {
      // ...
      double actual_temp = 0.0;
      if (temp.temperature_float_is_set()) {
        actual_temp = temp.temperature_float();
      } else {
        actual_temp = static_cast<double>(temp.temperature());
      }
    }

This is not uncommon to see in projects, and it has the advantage that old data, whether it is from a program running on an older machine or is from old recorded data, can be interpreted by newer code without additional machinery or features beyond the optional field type.
Older publishing code can also use the new definition without being updated to use the new ``temperature_float`` field, which is very forgiving for developers in a way, but likely wouldn't be good long term solution.

You can imagine other serialization features, like inheritance or type coercion, could be used to address this desired change, but in each case it relies on a feature of the serialization technology which may or may not be available in all middleware implementations for ROS 2.

Each of these approaches also requires a more sophisticated message API for the users than what is currently provided by ROS 2.
At the moment the user can access all fields of the message directly, i.e. "member based access" vs "method based access", and that would need to change in some way to use some of these features.

A different approach would be to simply update the type as follows:

.. code::

    # Temperature.msg
    uint64 timestamp
    float64 temperature

And also update any code publishing or subscribing to this type at the same time.
This is typically what happens right now in ROS 2, and also what happened historically in ROS 1.
This approach is simple and requires no additional serialization features, but obviously doesn't do anything on its own to help developers evolve their system while maintaining support for already deployed code and utilizing existing recorded data.

However, with additional tooling these cases can be handled without the code of the application knowing about.
Consider again the above example, but this time the update to the message was done without backwards compatibility in the message definition.
This means that publishing old recorded data, for example, will not work with new code that subscribes to the topic but expects the new version of the message.
For the purpose of this example, let's call the original message type ``Temperature`` and the one using ``float64`` we'll call ``Temperature'``.
So, if you have rosbag2 publishing ``Temperature`` messages and a program consuming ``Temperature'`` messages they will not communicate, unless you have an intermediate program doing the translation.

.. code::

    ┌─────────┐  publishes     ┌──────────────┐ publishes     ┌─────┐
    │ rosbag2 ├───────────────►│transfer func.├──────────────►│ App │
    └─────────┘  Temperature   └──────────────┘ Temperature'  └─────┘

The "transfer function" can be user-defined, or for simple changes (like changing the field type to a compatible type) it can be done automatically.
We already do something like this for the ROS 1 to ROS 2 bridge in order to handle changes between message types in ROS 1 and ROS 2, and something like this was also done for rosbags in ROS 1 with the "bag migration rules" feature.

.. TODO:: cite the above

This approach requires a few features, like the ability to have a single application read old and new versions of a message at the same time, and it requires more infrastructure and tooling to make it work, but it has the advantage of keeping both the publishing and subscribing code simple, i.e agnostic to the fact that there are other versions of the message, and it keeps the message type from being cluttered with vestigial fields.

Either way, a problem can usually be solved by changing a message in some of, if not all, of the of the above mentioned ways, and is often influenced by what the underlying technology allows for or encourages.
ROS 2 has special considerations on this topic because it can support different serialization technologies, though CDR is the default and most common right now, and those technologies have different capabilities.
It is neither desirable to depend on features of a specific technology, therefore tying ROS 2 to a specific technology, nor is it desirable suggest patterns that rely on features that only some serialization technologies provide, again tying ROS 2 to some specific technologies through their features.

We will require some features from the middleware and serialization technology, however, to handle evolving interfaces, but we should try to choose approaches which give ROS 2 the broadest support across middleware implementations, ideally while not limiting users from using specific features of the underlying technology when that suites them.

With those examples and design constraints as motivation, this REP makes a proposal on how to handle evolving message types in the following Specification section, as well as a rationale in the Rationale section and a discussion of alternatives in the Alternatives section and its sub-sections.

Terminology
===========

TODO


Specification
=============

The proposal is to provide tooling to help users identify when messages have changed, help users configure their system to convert between versions of messages on the fly, and help users write the code needed to convert between types when the conversion is not trivial.

Conceptual Overview
-------------------

Users will be able to calculate the "type version hash" for an interface (e.g. a message, service, or action) using the ``ros2 interface hash <package_name> <interface_name>`` command.
Additionally, if a topic has two types being used on it with the same type name, but different type versions, a warning will be logged and the endpoints that do not match will not communicate.

.. TODO:: how does this interact with serialization features like optional fields and inheritance? Is there a way to override this behavior when the hashes don't match but communication will work due to optional fields or inheritance?

When a mismatch is detected, the user can use predefined, or user-defined, "transfer functions" to convert between versions of the type until it is in the type they wish to send or receive.
They can use a tool that will look at a catalogue of available transfer functions to find a single transfer function, or a set of transfer functions, to get from the current type version to the desired type version.
The tool will start with the current type version and see if it can be automatically converted to the desired type version, or if it is accepted as an input to any user-defined transfer functions or if it can be automatically converted into one of the input type versions for the transfer functions.
It will continue to do this until it reaches the desired type version or it fails to find a path from the current to the desired type version.

Once the set of necessary transfer functions has been identified, the ROS graph can be changed to have one side of the topic be remapped onto a new topic name which indicates it is of a different version that what is desired, and then the transfer function can be run as a component node which subscribes to one version of the message, performs the conversion using the chain of transfer functions, and then publishes the other version of the message.
Tools will assist the user in making these remappings and running the necessary component nodes with the appropriate configurations, either from their launch file or from the command line.

.. TODO:: discuss the implications for large messages and the possibility of having the transfer functions be colocated with either the publisher or subscription more directly than with component nodes and remapping.

Once the mismatched messages are flowing through the transfer functions, communication should be possible and neither the publishing side nor the subscribing side have any specific knowledge of the conversions taking place or that any conversions are necessary.

In order to support this vision, three missing features will need to be added into ROS 2: controlling matching based on the type version hash (interface type enforcement), communicating the interface type description between nodes (inter-process type description distribution), and (de)serializing messages and services given only a type description of the interface and a buffer of bytes (runtime type introspection).

Interface Type Enforcement
--------------------------

In order to detect type version mismatches and enforce them, a way to uniquely identify versions is required, and this proposal uses type version hashes.

Type Version Hash
~~~~~~~~~~~~~~~~~

The type version hashes are not sequential and do not imply any rank among versions of the type. That is, given two version hashes of a type, there is no way to tell which is "newer".
The type version hash can only be used to determine if type versions are equal and if there exists a chain of transfer functions that can convert between them.
Because of this, when a change to a type is made, it may or may not be necessary to write transfer functions in both directions depending on how the interface is used.

In order to calculate the type version hashes so that they are stable and are not sensitive to trivial changes like changes in the comments or whitespace in the IDL file, the IDL file given by the user, which may be a ``.msg`` file, ``.idl`` file, or something else, is parsed and stored into a data structure which excludes things like comments but includes things that impact compatibility on the wire.

The data structure includes:

- A list of field names and types, but not default values
- The serialization format
- The serialization format version
- An optional user-defined interface version, or 0 if not provided

The resulting data structure is hashed using a standard SHA-1 method, resulting in a standard 160-bit (20-byte) hash value which is also generally known as a "message digest".
This hash is combined with a "type version hash standard version", the first of which will be ``IDLHASH-1``, with an ``@`` symbol, resulting in a complete type version hash like ``IDLHASH-1@<160-bit SHA-1 of data structure>``.
This allows the tooling to know if a hash mismatch is due to a change in this standard (what is being hashed) or due to a difference in the interface types themselves.

.. TODO:: is the list of field names and types sufficient? how to capture things like .idl annotations, etc... I'm thinking of serialization format specific entries can be added to this data structure, but need to sketch it out a bit more

Enforcing Type Version
~~~~~~~~~~~~~~~~~~~~~~

If the type version hash is available, it can be used as an additional constraint to determine if two endpoints (publishers and subscriptions) on a topic should communicate.

When creating a publisher or subscription, the caller normally provides: a topic name, QoS settings, and a topic type.
The topic type is represented as a string and is automatically deduced based on the type given to the create function, e.g. as a template parameter in C++ or the message type as an argument in Python.
For example, creating a publisher for ``std_msgs::msg::String`` in C++, may result in a topic type like ``std_msgs/msg/String``.
All of these items are used by the middleware to determine if two endpoints should communicate or not, and this REP proposes that the type version be added to this list of provided information.
From the user's perspective, nothing needs to change, as the type version can be extracted based on the topic type given either at the ``rcl`` layer or in the ``rmw`` implementation itself.
However, the type version would become something that the ``rmw`` implementation is provided and aware of in the course of creating a publisher or subscription, and therefore the job of using that information to enforce type compatibility would be left to the middleware, rather than implementing it as logic in ``rcl`` or other packages above the ``rmw`` API.

The method for implementing the detection and enforcement of type version mismatches is left up to the middleware, as some middlewares will have tools to make this efficient and others will implement something like what would be possible in the ``rcl`` and above layers.
By keeping this a detail of the ``rmw`` implementation, we allow the ``rmw`` implementations to make optimizations where they can.

Recommended Strategy for Enforcing that Type Versions Match
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the middleware has a feature to handle type compatibility already, as is the case with DDS-XTypes which is discussed later, then that can be used to enforce type safety, and then the type version hash can be used to warn the user when the communication may not happen due to a version mismatch, and also if can be put into recordings for future comparison.

However, if the middleware lacks this kind of feature, then the recommended strategy for accomplishing this in the ``rmw`` implementation is to simply concatenate the type name and the type version hash and then use that as the type name given to the underlying middleware.
This has the benefit of "just working" for most middlewares which at least match based on the name of the type, and it is simple, requiring no further custom hooks into the middleware's discovery or match making process.
However, the downside is that detecting the mismatch is more difficult and it also makes interoperating with ROS using the native middleware more difficult, as appending the version hash to the type name is just "one more thing" that you have to contend with when trying to connect non-ROS endpoints to a ROS graph.

.. TODO:: figure out if mismatched types produces a IncompatibleQoSOffered callback or not, then document the recommended way to detect type version mismatches, also look into ``DDS XTypes spec v1.3: 7.6.3.4.2: INCONSISTENT_TOPIC`` as a possible alternative

Notes for Implementing the Recommended Strategy with DDS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO

Interactions with DDS-XTypes or Similar Implicit Middleware Features
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO


.. TODO:: move the draft section with details here after one of these options is selected: USER_DATA+ignore, USER_DATA+discovery "plugin", append type hash to type name in DDS, use type hash in DDS partition

Inter-process Type Description Distribution
-------------------------------------------

.. TODO:: move the draft section over, and make a selection between: telnet/http server per context/participant under rmw layer, service per context/participant under rmw layer, telnet/http server per node under rmw layer, service per node above rmw layer, or some combination with way to configure which should be used.

Runtime Type Introspection
--------------------------

.. TODO:: terminology could be better? nothing off the top of my head, just deserves more bike-shedding.



Rationale
=========

TODO

Alternatives
------------

TODO

Use Type Hash from Middleware, e.g. from DDS-XTypes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Handle Detection of Version Mismatch "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO

Prevent Communication of Mismatched Versions "Above" rmw Layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TODO


Backwards Compatibility
=======================

TODO

Feature Progress
================

TODO


References
==========

.. [1] DDS-XTYPES 1.3
   (https://www.omg.org/spec/DDS-XTypes/1.3/About-DDS-XTypes/)


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
